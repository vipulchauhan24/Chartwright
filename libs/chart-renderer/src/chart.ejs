<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      #chart-container {
        position: relative;
        height: 100vh;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <div id="chart-container"></div>
    <script src="https://echarts.apache.org/en/js/vendors/echarts/dist/echarts.min.js"></script>
    <script>
      let port, chart;

      const MESSAGE_TYPES = Object.freeze({
        READY: 'ready',
        INIT: 'init',
        RENDER: 'render',
        CHART_INIT: 'chart-init',
        CHART_FINISHED: 'chart-finished',
        CHART_DISPOSE: 'chart-dispose',
        CHART_UPDATE: 'chart-update',
        CHART_DOWNLOAD: 'chart-download',
      });

      function dispose() {
        try {
          chart?.dispose();
          console.log('Chart disposed');
        } catch (error) {
          console.error('Error in disposing chart');
        }
      }

      function sendMessage(data) {
        port?.postMessage(data);
      }

      function onMessage(e) {
        switch (event.data.type) {
          case MESSAGE_TYPES.RENDER:
            const dom = document.getElementById('chart-container');
            dispose();
            chart = echarts.init(dom, null, {
              renderer: 'canvas',
              useDirtyRect: false,
            });
            chart.setOption(e.data.options, {
              notMerge: true,
              lazyUpdate: true,
              silent: true,
            });
            chart?.on('finished', function () {
              port.postMessage({ type: MESSAGE_TYPES.CHART_FINISHED });
            });
            port.postMessage({ type: MESSAGE_TYPES.CHART_INIT });
            break;
          case MESSAGE_TYPES.CHART_DISPOSE:
            dispose();
            break;
          case MESSAGE_TYPES.CHART_UPDATE:
            chart.setOption(e.data.options, {
              notMerge: true,
              lazyUpdate: true,
              silent: true,
            });
            break;
          case MESSAGE_TYPES.CHART_DOWNLOAD:
            const imageURI = chart.getDataURL({
              type: e.data.uriType,
              backgroundColor: e.data.backgroundColor,
            });
            sendMessage({
              type: MESSAGE_TYPES.CHART_DOWNLOAD,
              imageURI: imageURI,
              ...e.data,
            });
            break;

          default:
            break;
        }
      }

      // Receive port2 from host
      window.addEventListener('message', (event) => {
        if (event.origin !== window.origin) return; // basic check

        if (event.data.type === MESSAGE_TYPES.INIT && event.ports[0]) {
          port = event.ports[0];
          port.onmessage = onMessage;
          // Send a handshake back
          sendMessage({ type: MESSAGE_TYPES.READY });
        }
      });
    </script>
  </body>
</html>
